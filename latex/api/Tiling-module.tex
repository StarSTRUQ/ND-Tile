%
% API Documentation for ND-Tile
% Module Tiling
%
% Generated by epydoc 3.0.1
% [Thu Nov 17 17:48:21 2016]
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                          Module Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Tiling \textit{(module)}|(}
\section{Module Tiling}

    \label{Tiling}
\begin{alltt}

Tile an N-Dimensional Domain containing Point objects depending on a Tile decision function.

Copyright (c) 2016, Donald E. Willcox
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\end{alltt}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Tiling \textit{(module)}!Tiling.OutputWriter \textit{(class)}|(}
\subsection{Class OutputWriter}

    \label{Tiling:OutputWriter}
\begin{tabular}{cccccc}
% Line for object, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{Tiling.OutputWriter}}
\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{otype}={\tt None}, \textit{null}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    If otype==None, then OutputWriter will print to stdout. Otherwise, open
    a file named otype for writing. If null, write immediately returns and 
    does nothing.

\setlength{\parskip}{1ex}
      Overrides: object.\_\_init\_\_

    \end{boxedminipage}

    \label{Tiling:OutputWriter:close}
    \index{Tiling \textit{(module)}!Tiling.OutputWriter \textit{(class)}!Tiling.OutputWriter.close \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{close}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    If OutputWriter has a file open, then close it.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:OutputWriter:write}
    \index{Tiling \textit{(module)}!Tiling.OutputWriter \textit{(class)}!Tiling.OutputWriter.write \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{write}(\textit{self}, \textit{content})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Print content to stdout if no file object is available in ofile. If 
    there is a file object in ofile, then write content to the file.

    When writing content to a file, append a newline.

\setlength{\parskip}{1ex}
    \end{boxedminipage}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_repr\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}

    \index{Tiling \textit{(module)}!Tiling.OutputWriter \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Tiling \textit{(module)}!Tiling.BCTypes \textit{(class)}|(}
\subsection{Class BCTypes}

    \label{Tiling:BCTypes}
\begin{tabular}{cccccc}
% Line for object, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{Tiling.BCTypes}}
\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_init\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_repr\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                            Class Variables                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Class Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright u\-p\- & \raggedright \textbf{Value:} 
{\tt + 1}&\\
\cline{1-2}
\raggedright n\-o\-n\-e\- & \raggedright \textbf{Value:} 
{\tt None}&\\
\cline{1-2}
\raggedright d\-o\-w\-n\- & \raggedright \textbf{Value:} 
{\tt -1}&\\
\cline{1-2}
\raggedright t\-i\-l\-e\- & \raggedright \textbf{Value:} 
{\tt + 2}&\\
\cline{1-2}
\raggedright p\-o\-i\-n\-t\- & \raggedright \textbf{Value:} 
{\tt + 3}&\\
\cline{1-2}
\raggedright a\-l\-l\-\_\-t\-y\-p\-e\-s\- & \raggedright \textbf{Value:} 
{\tt + 4}&\\
\cline{1-2}
\end{longtable}

    \index{Tiling \textit{(module)}!Tiling.BCTypes \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Tiling \textit{(module)}!Tiling.BCDim \textit{(class)}|(}
\subsection{Class BCDim}

    \label{Tiling:BCDim}
\begin{tabular}{cccccc}
% Line for object, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{Tiling.BCDim}}
\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self})

\setlength{\parskip}{2ex}
    x.\_\_init\_\_(...) initializes x; see help(type(x)) for signature

\setlength{\parskip}{1ex}
      Overrides: object.\_\_init\_\_ 	extit{(inherited documentation)}

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_repr\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}

    \index{Tiling \textit{(module)}!Tiling.BCDim \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Tiling \textit{(module)}!Tiling.TETypes \textit{(class)}|(}
\subsection{Class TETypes}

    \label{Tiling:TETypes}
\begin{tabular}{cccccc}
% Line for object, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{Tiling.TETypes}}
\end{tabular}

Tiling Error Types


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_init\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_repr\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                            Class Variables                            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Class Variables}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\raggedright c\-a\-n\-n\-o\-t\-\_\-s\-t\-a\-r\-t\-\_\-p\-o\-i\-n\-t\- & \raggedright \textbf{Value:} 
{\tt 0}&\\
\cline{1-2}
\raggedright c\-a\-n\-n\-o\-t\-\_\-e\-n\-c\-l\-o\-s\-e\-\_\-e\-n\-o\-u\-g\-h\-\_\-p\-o\-i\-n\-t\-s\- & \raggedright \textbf{Value:} 
{\tt 1}&\\
\cline{1-2}
\raggedright f\-e\-w\-\_\-p\-o\-i\-n\-t\-s\-\_\-r\-e\-m\-a\-i\-n\- & \raggedright \textbf{Value:} 
{\tt 2}&\\
\cline{1-2}
\end{longtable}

    \index{Tiling \textit{(module)}!Tiling.TETypes \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Tiling \textit{(module)}!Tiling.DMCycle \textit{(class)}|(}
\subsection{Class DMCycle}

    \label{Tiling:DMCycle}
\begin{tabular}{cccccc}
% Line for object, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{Tiling.DMCycle}}
\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{dm}={\tt None})

\setlength{\parskip}{2ex}
    x.\_\_init\_\_(...) initializes x; see help(type(x)) for signature

\setlength{\parskip}{1ex}
      Overrides: object.\_\_init\_\_ 	extit{(inherited documentation)}

    \end{boxedminipage}

    \label{Tiling:DMCycle:cycle}
    \index{Tiling \textit{(module)}!Tiling.DMCycle \textit{(class)}!Tiling.DMCycle.cycle \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{cycle}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_repr\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}

    \index{Tiling \textit{(module)}!Tiling.DMCycle \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Tiling \textit{(module)}!Tiling.TilingError \textit{(class)}|(}
\subsection{Class TilingError}

    \label{Tiling:TilingError}
\begin{tabular}{cccccccccc}
% Line for object, linespec=[False, False, False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
&&
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
&&
&&
  \\
% Line for exceptions.BaseException, linespec=[False, False]
\multicolumn{4}{r}{\settowidth{\BCL}{exceptions.BaseException}\multirow{2}{\BCL}{exceptions.BaseException}}
&&
&&
  \\\cline{5-5}
  &&&&\multicolumn{1}{c|}{}
&&
&&
  \\
% Line for exceptions.Exception, linespec=[False]
\multicolumn{6}{r}{\settowidth{\BCL}{exceptions.Exception}\multirow{2}{\BCL}{exceptions.Exception}}
&&
  \\\cline{7-7}
  &&&&&&\multicolumn{1}{c|}{}
&&
  \\
&&&&&&\multicolumn{2}{l}{\textbf{Tiling.TilingError}}
\end{tabular}

Error class for various kinds of tiling errors that can arise.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{err\_type}, \textit{err\_tile}={\tt None}, \textit{scratch\_points}={\tt None}, \textit{message}={\tt ''})

\setlength{\parskip}{2ex}
    x.\_\_init\_\_(...) initializes x; see help(type(x)) for signature

\setlength{\parskip}{1ex}
      Overrides: object.\_\_init\_\_ 	extit{(inherited documentation)}

    \end{boxedminipage}


\large{\textbf{\textit{Inherited from exceptions.Exception}}}

\begin{quote}
\_\_new\_\_()
\end{quote}

\large{\textbf{\textit{Inherited from exceptions.BaseException}}}

\begin{quote}
\_\_delattr\_\_(), \_\_getattribute\_\_(), \_\_getitem\_\_(), \_\_getslice\_\_(), \_\_reduce\_\_(), \_\_repr\_\_(), \_\_setattr\_\_(), \_\_setstate\_\_(), \_\_str\_\_(), \_\_unicode\_\_()
\end{quote}

\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_format\_\_(), \_\_hash\_\_(), \_\_reduce\_ex\_\_(), \_\_sizeof\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from exceptions.BaseException}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright args, message}\\
\cline{1-2}
\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}

    \index{Tiling \textit{(module)}!Tiling.TilingError \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Tiling \textit{(module)}!Tiling.Point \textit{(class)}|(}
\subsection{Class Point}

    \label{Tiling:Point}
\begin{tabular}{cccccc}
% Line for object, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{Tiling.Point}}
\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{r}={\tt []}, \textit{v}={\tt None})

\setlength{\parskip}{2ex}
    x.\_\_init\_\_(...) initializes x; see help(type(x)) for signature

\setlength{\parskip}{1ex}
      Overrides: object.\_\_init\_\_ 	extit{(inherited documentation)}

    \end{boxedminipage}

    \label{Tiling:Point:norm_dist_to_pt}
    \index{Tiling \textit{(module)}!Tiling.Point \textit{(class)}!Tiling.Point.norm\_dist\_to\_pt \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{norm\_dist\_to\_pt}(\textit{self}, \textit{b})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Point:order_nn}
    \index{Tiling \textit{(module)}!Tiling.Point \textit{(class)}!Tiling.Point.order\_nn \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{order\_nn}(\textit{self}, \textit{plist}={\tt []})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Point:get_average_dist_nn}
    \index{Tiling \textit{(module)}!Tiling.Point \textit{(class)}!Tiling.Point.get\_average\_dist\_nn \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_average\_dist\_nn}(\textit{self}, \textit{plist}={\tt []}, \textit{num\_neighbors}={\tt 1})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_repr\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}

    \index{Tiling \textit{(module)}!Tiling.Point \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Tiling \textit{(module)}!Tiling.Plane \textit{(class)}|(}
\subsection{Class Plane}

    \label{Tiling:Plane}
\begin{tabular}{cccccc}
% Line for object, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{Tiling.Plane}}
\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{points}={\tt None}, \textit{fit\_guess}={\tt []}, \textit{dm}={\tt None}, \textit{lo}={\tt []}, \textit{hi}={\tt []}, \textit{writer}={\tt None})

\setlength{\parskip}{2ex}
    x.\_\_init\_\_(...) initializes x; see help(type(x)) for signature

\setlength{\parskip}{1ex}
      Overrides: object.\_\_init\_\_ 	extit{(inherited documentation)}

    \end{boxedminipage}

    \label{Tiling:Plane:close}
    \index{Tiling \textit{(module)}!Tiling.Plane \textit{(class)}!Tiling.Plane.close \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{close}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Manually cleanup. Used for closing open file handles.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Plane:print_fit_report}
    \index{Tiling \textit{(module)}!Tiling.Plane \textit{(class)}!Tiling.Plane.print\_fit\_report \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{print\_fit\_report}(\textit{self}, \textit{writer}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Prints report of the fit to the writer. If writer==None, use 
    self.writer.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Plane:compute_pars}
    \index{Tiling \textit{(module)}!Tiling.Plane \textit{(class)}!Tiling.Plane.compute\_pars \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{compute\_pars}(\textit{self}, \textit{points}, \textit{fit\_guess}={\tt []})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_repr\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}

    \index{Tiling \textit{(module)}!Tiling.Plane \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}|(}
\subsection{Class Tile}

    \label{Tiling:Tile}
\begin{tabular}{cccccc}
% Line for object, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{Tiling.Tile}}
\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{points}={\tt []}, \textit{lo}={\tt []}, \textit{hi}={\tt []}, \textit{fit\_guess}={\tt []}, \textit{dm}={\tt None}, \textit{smask}={\tt None}, \textit{virtual}={\tt False}, \textit{writer}={\tt None})

\setlength{\parskip}{2ex}
    x.\_\_init\_\_(...) initializes x; see help(type(x)) for signature

\setlength{\parskip}{1ex}
      Overrides: object.\_\_init\_\_ 	extit{(inherited documentation)}

    \end{boxedminipage}

    \label{Tiling:Tile:close}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.close \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{close}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Manually cleanup. Used for closing open file handles.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:extend_dimension}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.extend\_dimension \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{extend\_dimension}(\textit{self}, \textit{di}, \textit{dx}, \textit{surface}, \textit{direction})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_dim_thickness}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_dim\_thickness \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_dim\_thickness}(\textit{self}, \textit{di})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given the dimension di, return the thickness of this tile along di.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_thinnest_dimension}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_thinnest\_dimension \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_thinnest\_dimension}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Find the dimension di in which this Tile is thinnest.

    Also find the thickness dx along dimension di.

    Return (di, dx)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:order_thinnest_dimensions}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.order\_thinnest\_dimensions \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{order\_thinnest\_dimensions}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Return the dimensions of this Tile in a list ordered by the Tile 
    thickness in each dimension from smallest to largest.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:colocated_with}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.colocated\_with \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{colocated\_with}(\textit{self}, \textit{btile}, \textit{di}={\tt -1})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Determine whether self and btile are colocated.

    If the optional argument di is provided, determines whether self and 
    btile are colocated only considering dimension di.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:gen_vertices}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.gen\_vertices \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{gen\_vertices}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Return a generator for the vertices of this Tile.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:create_surface}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.create\_surface \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{create\_surface}(\textit{self}, \textit{di}, \textit{surface})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Make and return the surface of this Tile defined by the constant 
    dimension (di) where the surface normal of Tile along di on this 
    surface lies in the direction given by (surface)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_surfaces}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_surfaces \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_surfaces}(\textit{self}, \textit{dj}={\tt -1})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Return the surfaces for this Tile as Tile objects.

    The distinguishing feature of the surface relative to this Tile is 
    that, although the surface and Tile are of the same dimensionality, 
    there is at least one dimension di in which the surface tile has lo[di]
    == hi[di] == constant.

    In case this tile is already a surface, then only set the constraint 
    lo[di] == hi[di] == constant if lo[di] != hi[di].

    If dj is provided, only return surfaces for which lo[dj] == hi[dj] == 
    constant.

    Otherwise return all such surfaces if dj is not provided (-1). I'm 
    using -1 here because 0 is a valid dimension but tests as a boolean 
    False.

    If dj is provided and it is not a nonconstant dimension, then return an
    empty list.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_constant_dimensions}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_constant\_dimensions \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_constant\_dimensions}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Find all dimensions di for which lo[di] == hi[di] == constant

    Return a list of tuples [(di, constant), ...] satisfying that 
    condition.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_nonconstant_dimensions}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_nonconstant\_dimensions \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_nonconstant\_dimensions}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Find all dimensions di for which lo[di] != hi[di]

    Return a list of such dimensions di.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:print_tile_report}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.print\_tile\_report \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{print\_tile\_report}(\textit{self}, \textit{tile\_number}={\tt None}, \textit{writer}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Prints report of this Tile to the writer. If writer==None, use 
    self.writer.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:print_fit_report}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.print\_fit\_report \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{print\_fit\_report}(\textit{self}, \textit{writer}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Prints report of the fit on this Tile to the writer. If writer==None, 
    use self.writer.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_volume}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_volume \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_volume}(\textit{self}, \textit{dom\_lo}={\tt []}, \textit{dom\_hi}={\tt []})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Computes volume of the Tile. If [lo, hi] is undefined, return None. If 
    dom\_lo and dom\_hi are supplied, normalize the tile dimensions by the 
    dimensions of domain lo and hi first before computing a normalized 
    volume.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:boundary_minimize}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.boundary\_minimize \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{boundary\_minimize}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given the points in the Tile, set the boundary defined by [lo, hi] to 
    the minimum surface enclosing the points.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:extend_points}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.extend\_points \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{extend\_points}(\textit{self}, \textit{plist}={\tt []})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given the list of points (plist), extends the Tile if necessary to 
    enclose them.

    Set the Tile boundaries to the minimum volume enclosing the provided 
    points.

    Do nothing if no points are provided.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:overlaps_point_dimension}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.overlaps\_point\_dimension \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{overlaps\_point\_dimension}(\textit{self}, \textit{refpoint}, \textit{di})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Checks to see if self overlaps refpoint in the dimension di:

    refpoint must be a Point object

    di must be an integer in range(self.dm)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_point_occlusions}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_point\_occlusions \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_point\_occlusions}(\textit{self}, \textit{points}, \textit{di})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given a list of points (points), find the points which will occlude 
    self along dimension di and thus can set bounds.

    Return a list of such points.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_point_constraints}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_point\_constraints \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_point\_constraints}(\textit{self}, \textit{points}, \textit{di}, \textit{bcdi}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Get point based [lo, hi] constraints along dimension di for this Tile.

    Return boundary conditions along dimension di in bcdi.

    Calculates point occlusions from the list of points (points)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:overlaps_tile_dimension}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.overlaps\_tile\_dimension \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{overlaps\_tile\_dimension}(\textit{self}, \textit{reftile}, \textit{di})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Checks to see if self overlaps reftile in the dimension di:

    reftile must be a Tile object

    di must be an integer in range(self.dm).

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:overlaps_tiles}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.overlaps\_tiles \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{overlaps\_tiles}(\textit{self}, \textit{tlist}={\tt []})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Checks to see if self overlaps any of the tiles in tlist

    Returns list of tiles in tlist which overlap self

    Returns the empty list if no tiles in tlist overlap self

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_tile_occlusions}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_tile\_occlusions \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_tile\_occlusions}(\textit{self}, \textit{tiles}, \textit{di})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given a list of tile objects (tiles), find the tiles in tiles which are
    not self which will occlude self along dimension di and thus can set 
    bounds.

    Return a list of such tiles.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:whether_occludes_tile}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.whether\_occludes\_tile \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{whether\_occludes\_tile}(\textit{self}, \textit{atile}, \textit{di})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Determine whether self and atile occlude along dimension di.

    Return True if they occlude, False otherwise.

    By design, occlusion is false if the tiles overlap along dimension di 
    or if they are the same tile.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:whether_osculates_tile}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.whether\_osculates\_tile \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{whether\_osculates\_tile}(\textit{self}, \textit{atile}, \textit{di}, \textit{direction}={\tt BCTypes.none})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Determine whether self and atile osculate on any surface in dimension 
    di.

    If direction is supplied, then the osculation surface relative to self 
    should have the surface normal mask equal to direction.

    Find the surface of self which is osculated (sface)

    Also find the ctile which is the intersection of the osculating 
    surfaces of self and atile.

    Return (sface, ctile) in case atile osculates self.

    Otherwise return (None, None)

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_tile_intersection}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_tile\_intersection \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_tile\_intersection}(\textit{self}, \textit{atile})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Return the tile which is the intersection of self and atile.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_tile_constraints}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_tile\_constraints \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_tile\_constraints}(\textit{self}, \textit{tiles}, \textit{di}, \textit{bcdi}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Get tile based [lo, hi] constraints along dimension di for this Tile.

    Return boundary conditions along dimension di in bcdi.

    Calculates tile occlusions from the list tiles.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_hypothetical_extend}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_hypothetical\_extend \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_hypothetical\_extend}(\textit{self}, \textit{points}={\tt []}, \textit{avoid\_tiles}={\tt None}, \textit{greedy\_absorb\_points}={\tt []})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:extend_min_volume}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.extend\_min\_volume \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{extend\_min\_volume}(\textit{self}, \textit{plist}={\tt []}, \textit{avoid\_tiles}={\tt None}, \textit{decision\_fun}={\tt None}, \textit{dom\_lo}={\tt []}, \textit{dom\_hi}={\tt []})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given the list of points (plist), extends the Tile by adding one point 
    from plist to Tile where the point is selected from plist such that it 
    minimizes the normalized volume of Tile. The normalized volume is the 
    product of tile dimensions, each normalized by the extent of the domain
    in each dimension, passed via dom\_lo and dom\_hi arguments. If either 
    of those arguments are not supplied, then do not normalize the volume.

    Returns plist where the selected point is popped from the list.

    If avoid\_tiles is passed, it should be a list of Tile objects. The 
    current Tile will then only be extended such that it does not intersect
    the tiles in avoid\_tiles.

    If a function is passed as decision\_fun, this Tile will be passed to 
    the 'decision function' to determine whether to extend the tile. 
    decision\_fun should take a single Tile argument and return True or 
    False

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:which_points_within}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.which\_points\_within \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{which\_points\_within}(\textit{self}, \textit{pointlist}={\tt []}, \textit{lo}={\tt []}, \textit{hi}={\tt []})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_subtile}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_subtile \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_subtile}(\textit{self}, \textit{lo}, \textit{hi})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:do_plane_fit}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.do\_plane\_fit \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{do\_plane\_fit}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_coeff_det}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_coeff\_det \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_coeff\_det}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_L2_norm_resd}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_L2\_norm\_resd \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_L2\_norm\_resd}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Tile:get_tilde_resd}
    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}!Tiling.Tile.get\_tilde\_resd \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_tilde\_resd}(\textit{self})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_repr\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}

    \index{Tiling \textit{(module)}!Tiling.Tile \textit{(class)}|)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                           Class Description                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}|(}
\subsection{Class Domain}

    \label{Tiling:Domain}
\begin{tabular}{cccccc}
% Line for object, linespec=[False]
\multicolumn{2}{r}{\settowidth{\BCL}{object}\multirow{2}{\BCL}{object}}
&&
  \\\cline{3-3}
  &&\multicolumn{1}{c|}{}
&&
  \\
&&\multicolumn{2}{l}{\textbf{Tiling.Domain}}
\end{tabular}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                Methods                                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Methods}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{\_\_init\_\_}(\textit{self}, \textit{points}={\tt []}, \textit{lo}={\tt []}, \textit{hi}={\tt []}, \textit{dm}={\tt None}, \textit{plot\_lo}={\tt []}, \textit{plot\_hi}={\tt []}, \textit{point\_normalize}={\tt True}, \textit{plot\_dimfrac}={\tt 0.9}, \textit{last\_domain\_slice}={\tt (None,None)}, \textit{dlabels}={\tt []}, \textit{ilabel}={\tt None}, \textit{logfile}={\tt None}, \textit{summaryfile}={\tt None})

\setlength{\parskip}{2ex}
    x.\_\_init\_\_(...) initializes x; see help(type(x)) for signature

\setlength{\parskip}{1ex}
      Overrides: object.\_\_init\_\_ 	extit{(inherited documentation)}

    \end{boxedminipage}

    \label{Tiling:Domain:close}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.close \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{close}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Manually cleanup. Used for closing open file handles.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:photogenic_plot_limits}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.photogenic\_plot\_limits \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{photogenic\_plot\_limits}(\textit{self}, \textit{dimfrac}={\tt 0.9})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Compute the appropriate plot limits [self.plot\_lo, self.plot\_hi] for 
    which 2-D domain slices will plot the domain [self.lo, self.hi] such 
    that the domain extents in each dimension occupy the fraction dimfrac 
    of their corresponding axis.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:plot_domain_slice}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.plot\_domain\_slice \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{plot\_domain\_slice}(\textit{self}, \textit{dimx}={\tt 0}, \textit{dimy}={\tt 1}, \textit{save\_num}={\tt None}, \textit{show\_tile\_id}={\tt True}, \textit{save\_last\_figure}={\tt False}, \textit{underlay\_figure\_axis}={\tt None}, \textit{show\_plot}={\tt False})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:plot_domain_slice_scratch}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.plot\_domain\_slice\_scratch \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{plot\_domain\_slice\_scratch}(\textit{self}, \textit{stile}, \textit{dimx}={\tt 0}, \textit{dimy}={\tt 1}, \textit{save\_num}={\tt None}, \textit{show\_tile\_id}={\tt True}, \textit{save\_last\_figure}={\tt False}, \textit{underlay\_figure\_axis}={\tt None}, \textit{show\_plot}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given a scratch tile, add it to the tiles in this domain, plot the 
    domain slice, and then pop the tile from the domain tiles so the domain
    is unaffected.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:print_domain_report}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.print\_domain\_report \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{print\_domain\_report}(\textit{self}, \textit{writer}={\tt None})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:bc_init_mask_points}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.bc\_init\_mask\_points \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{bc\_init\_mask\_points}(\textit{self}, \textit{plist})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:propagate_tile_perturbation}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.propagate\_tile\_perturbation \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{propagate\_tile\_perturbation}(\textit{self}, \textit{from\_tile}, \textit{di}, \textit{dx}, \textit{surface}, \textit{direction}, \textit{ignore\_tiles}={\tt []}, \textit{dry\_run}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Extend the boundaries of from\_tile along dimension di by length dx.

    Find the other tiles in the domain which extending this boundary would 
    either interfere with or pull away from if it already osculates them 
    along dimension di. Correct those tile dimensions and propagate the 
    changes throughout the domain recursively. Never shrink a tile by more 
    than dx if it's of width dx or smaller. In that case, return False to 
    indicate the propagation could not succeed.

    The surface mask smask of this Tile will be checked and if it is not 
    equal to BCTypes.none to indicate this Tile is a surface along 
    dimension di, then expand the surface outwards in the direction of 
    smask.

    Surface and Direction should be either BCTypes.up or BCTypes.down to 
    indicate whether lo or hi is to be shifted and in what direction.

    If ignore\_tiles, then ignore propagating the perturbation to the tiles
    in ignore\_tiles. This is an aid for recursively propagating throughout
    the domain.

    If dry\_run == True, then do not actually perform any propagation but 
    do check the domain tiles recursively to see if the propagation is 
    allowed.

    Returns False if the perturbation could not be applied to from\_tile, 
    returns True otherwise.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:multi_propagate_tile_perturbation}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.multi\_propagate\_tile\_perturbation \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{multi\_propagate\_tile\_perturbation}(\textit{self}, \textit{tosc}, \textit{di}, \textit{dx}, \textit{surface}, \textit{direction}, \textit{ignore\_tiles}={\tt []}, \textit{dry\_run}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Wrapper for propagate\_tile\_perturbation that takes a list tosc of 
    (btile, sface, ctile) where btile is to be perturbed and propagated in 
    direction if sface's surface mask matches surface.

    tosc contents are as returned by self.get\_osculating\_tiles.

    Returns True if the propagation succeeded, False otherwise.

    Only actually applies the propagation if dry\_run == False.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:get_tile_boundaries}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.get\_tile\_boundaries \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_tile\_boundaries}(\textit{self}, \textit{atile}, \textit{di}, \textit{allow\_bc\_types}={\tt [BCTypes.all\_types]})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given atile and a dimension di, return the [lo, hi] boundaries in a 
    BCDim object.

    Account for the types of boundary conditions listed in 
    allow\_bc\_types.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:set_tile_boundaries}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.set\_tile\_boundaries \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{set\_tile\_boundaries}(\textit{self}, \textit{atile}, \textit{allow\_bc\_types}={\tt [BCTypes.all\_types]})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given atile, sets its [lo, hi] boundaries in each dimension.

    Also updates the boundary masks for adjacent points in the tiling list 
    scratch\_points.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:tiling_decision_function}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.tiling\_decision\_function \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{tiling\_decision\_function}(\textit{self}, \textit{L2r\_thresh}={\tt None}, \textit{coeff\_det\_thresh}={\tt None}, \textit{tilde\_resd\_thresh}={\tt None}, \textit{tilde\_resd\_factor}={\tt None})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:form_tile}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.form\_tile \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{form\_tile}(\textit{self}, \textit{decision\_function}={\tt None}, \textit{plot\_intermediate}={\tt False})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:extend_existing_tiles}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.extend\_existing\_tiles \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{extend\_existing\_tiles}(\textit{self}, \textit{decision\_function}={\tt None})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Extends all existing tiles, gobbling up scratch\_points as possible.

    Do this by figuring out which tile can best include each of the 
    remaining scratch\_points, given the decision\_function constraint.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:bound_existing_tiles}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.bound\_existing\_tiles \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{bound\_existing\_tiles}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Given the tiles in self.tiles, update all their tile-based boundaries 
    until no further updates can be made.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:get_osculating_tiles}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.get\_osculating\_tiles \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{get\_osculating\_tiles}(\textit{self}, \textit{atile}, \textit{di}, \textit{direction}={\tt BCTypes.none}, \textit{get\_other\_sface}={\tt False}, \textit{return\_other\_tile}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Get the tiles in Domain which osculate atile along the dimension di. 
    Return them as a list tosc = [(sface, ctile), ...] where sface and 
    ctile are as in Tile.whether\_osculates\_tile

    If direction == BCTypes.up or direction == BCTypes.down then only 
    return the tiles which osculate atile such that the osculating surface 
    of atile has a surface normal oriented along direction. Otherwise, if 
    direction == BCTypes.none, return tiles which osculate atile in any 
    direction along di. Note that this direction should be relative to 
    atile regardless the value of get\_other\_sface.

    If get\_other\_sface, then sface will correspond to the surface of the 
    Tile which osculates self.

    If return\_other\_tile, will return the tuples [(stile, sface, ctile), 
    ...] where stile is the Tile of which sface is the surface.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:do_empty_tiling}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.do\_empty\_tiling \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{do\_empty\_tiling}(\textit{self}, \textit{plot\_tile\_surfaces}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Creates empty virtual subtiles to cover the domain dom.

    Adds the created virtual subtiles to the domain dom.

    Returns True if virtual Tiles were created.

    Returns False if no virtual Tiles could be created.

    Because the Domain Tile loop doesn't update itself as Tiles are added 
    to the Domain, you should loop over this function until it returns None
    to indicate the entire Domain has been Tiled.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:shrink_virtual_tiles}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.shrink\_virtual\_tiles \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{shrink\_virtual\_tiles}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Shrink a virtual tile V in the domain to zero volume by rearranging 
    neighboring tiles.

    The algorithm is outlined below: Pop a virtual tile V off the Domain's 
    list of virtual\_tiles. Shrink virtual tile V by identifying its 
    thinnest dimension di (of width W) and finding the tiles B of maximum 
    volume with surfaces S which V osculates along di (B may be up or down 
    relative to di, but not both). Take the surfaces S and form a virtual 
    tile (SW) of thickness W extending from S in the direction of V. Find 
    all tiles T, T != V, which SW overlaps. Shrink all tiles T away from B 
    in the dimension di by length W. Expand tiles B into the volume of SW. 
    Remove virtual tile V from domain. Return and Repeat until no virtual 
    tiles remain.

    Real or virtual tiles will have a problem if they osculate the virtual 
    tile but are thinner than the virtual tile in the osculating dimension.
    To get around that, shrink\_virtual\_tiles should check to see if its 
    smallest dimension is not thicker than its osculating tiles along that 
    dimension. If that's not true, then it will not be possible to reduce 
    such a virtual tile.

    Reallocate points to real tiles and repeat fitting to update stats. 
    This has to be done in whatever code calls this function.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:create_virtual_tiles}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.create\_virtual\_tiles \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{create\_virtual\_tiles}(\textit{self}, \textit{make\_plots}={\tt False}, \textit{plot\_tile\_surfaces}={\tt False})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Tile all untiled space in the domain into virtual tiles and add them to
    self.virtual\_tiles.

    Returns True if a new virtual tile was created. Returns False 
    otherwise.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:static_tile_assign_points}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.static\_tile\_assign\_points \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{static\_tile\_assign\_points}(\textit{self})

    \vspace{-1.5ex}

    \rule{\textwidth}{0.5\fboxrule}
\setlength{\parskip}{2ex}
    Statically assign points to the tiles in the Domain and update the fits
    on those tiles. Existing points in the tiles are reset to only those 
    points assigned here.

\setlength{\parskip}{1ex}
    \end{boxedminipage}

    \label{Tiling:Domain:do_domain_tiling}
    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}!Tiling.Domain.do\_domain\_tiling \textit{(method)}}

    \vspace{0.5ex}

\hspace{.8\funcindent}\begin{boxedminipage}{\funcwidth}

    \raggedright \textbf{do\_domain\_tiling}(\textit{self}, \textit{L2r\_thresh}={\tt None}, \textit{coeff\_det\_thresh}={\tt None}, \textit{tilde\_resd\_thresh}={\tt None}, \textit{tilde\_resd\_factor}={\tt None}, \textit{attempt\_virtual\_shrink}={\tt False}, \textit{plot\_tile\_surfaces}={\tt False}, \textit{plot\_intermediate}={\tt False}, \textit{plot\_tiling}={\tt False}, \textit{plot\_final}={\tt True})

\setlength{\parskip}{2ex}
\setlength{\parskip}{1ex}
    \end{boxedminipage}


\large{\textbf{\textit{Inherited from object}}}

\begin{quote}
\_\_delattr\_\_(), \_\_format\_\_(), \_\_getattribute\_\_(), \_\_hash\_\_(), \_\_new\_\_(), \_\_reduce\_\_(), \_\_reduce\_ex\_\_(), \_\_repr\_\_(), \_\_setattr\_\_(), \_\_sizeof\_\_(), \_\_str\_\_(), \_\_subclasshook\_\_()
\end{quote}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                              Properties                               %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \subsubsection{Properties}

    \vspace{-1cm}
\hspace{\varindent}\begin{longtable}{|p{\varnamewidth}|p{\vardescrwidth}|l}
\cline{1-2}
\cline{1-2} \centering \textbf{Name} & \centering \textbf{Description}& \\
\cline{1-2}
\endhead\cline{1-2}\multicolumn{3}{r}{\small\textit{continued on next page}}\\\endfoot\cline{1-2}
\endlastfoot\multicolumn{2}{|l|}{\textit{Inherited from object}}\\
\multicolumn{2}{|p{\varwidth}|}{\raggedright \_\_class\_\_}\\
\cline{1-2}
\end{longtable}

    \index{Tiling \textit{(module)}!Tiling.Domain \textit{(class)}|)}
    \index{Tiling \textit{(module)}|)}
